
QUEUE

constant IDX_UNDEF : integer = -1
constant CAPACITY : integer = 100
{ *** Definisi elemen dan address *** }

type ElType : integer
type ElType: <	id: integer,
		cost: integer > { elemen Queue }


{ *** Definisi Type Queue *** }
type Queue : < buffer : array [0-CAPACITY-1] of ElType
idxHead : integer,
idxTail : integer >

{ Definisi Queue kosong: idxHead = idxTail = IDX_UNDEF }

{ Definisi akses dengan Selektor :
HEAD(Q), TAIL(Q), IDX_HEAD(Q), IDX_TAIL(Q)
dengan Q adalah Queue}



procedure CreateSet (output S : set)

KAMUS LOKAL

ALGORITMA
S.idxHead <- 0


procedure add(input/output S: Set, input X : Eltype)

KAMUS LOKAL

ALGORITMA
if (isIn(S, X)) then
output (“Elemen sudah ada dalam set”)
else
S[Length(S)] <- X


function union(S1, S2: Set) -> Set

KAMUS LOKAL
S3 : Set

ALGORITMA
i traversal [0.. Length(S1)]
S3[i] <- S1[i]
i traversal [0 .. Length(S2)-1]
if not isIn(S1, S2[i]) then
S3[Length(S3)] <- S2[i]
else
continue


boolean isEmpty(Queue Q) {
return (idxHead(Q) == IDX_UNDEF) && (idxTail(Q) == IDX_UNDEF);
}


boolean isFull(Queue Q) {
return (idxHead(Q) == 0) && (idxTail(Q) == CAPACITY-1);
}

	
int length(Queue Q) {
int x, length;
x = idxTail(Q) – idxHead(Q) + CAPACITY;
length = (x mod CAPACITY) + 1;
return length;
}


void CreateQueue(Queue Q){
idxHead = IDX_UNDEF;
idxTail = IDX_UNDEF;
}


void enqueue(Queue *Q, ElType val) {
/* Q tidak penuh */
if (isEmpty(*Q)) {
idxHead(*Q) = 0;
idxTail(*Q) = 0;
} 
else {
Q.buffer[idxTail+1] = val;
idxTail(*Q) = idxTail(*Q) + 1;
}
}


void dequeue(Queue *Q, ElType val) {
/* Q tidak kosong */
val = Q.buffer[idxHead];
if (idxHead(*Q) == idxTail(*Q)) {
idxHead(*Q) = IDX_UNDEF;
idxTail(*Q) = IDX_UNDEF;
}
else{
idxHead(*Q) = idxHead(*Q) + 1;
}
}
q.buffer[q.idxTail].id ← val.id
q.buffer[q.idxTail].cost ← val.cost
j ← q.idxTail
k ← q.idxTail-1
while (q.buffer[k].cost > q.buffer[j].cost) do
	temp.id ← q.buffer[j].id
	temp.cost ← q.buffer[j].cost
	q.buffer[j].id ← q.buffer[k].id
	q.buffer[j].cost ← q.buffer[k].cost
	q.buffer[k].id ← temp.id
	q.buffer[k].cost ← temp.cost
	j ← j-1
	k ← k-1

Constant BINER = 0
Type Biner :<buffer : array {0..MAX-1] of BINER, length : integer>
Constant MARK = “.”
Constant BLANK = “ “

procedure splitToThree (input Q : Queue, input ratio : real, output Q1,Q2,Q3 : Queue)
KAMUS LOKAL
val, Q_length, Q1_length, Q2_length, Q3_length, Qth : integer
temp1, temp2 : Queue
ALGORITMA
	CreateQueue(temp1)
	CreateQueue(temp2)
	Q_length<-0
	val<-0

	while not isEmpty(Q) do
		deqeueue(Q,val)
		enqueue(temp1,val)
		enqueue(temp2,val)
		Q_length<-Q_length+1

	while not isEmpty(temp1) do
		deqeueue(temp1,val)
		enqueue(Q,val)

	Q1_length <- ceil(ratio*Q_length)
	Q2_length <- (Q_length-Q1_length)/2
	if (Q_length-Q1_length)%2=1 then
		Q3_length<-Q2_length+1
	else
		Q3_length<-Q2_length
	
	cnt1 <- 0
	cnt2 <- 0
	cnt3 <- 0
	Qth <- 0
	while not isEmpty(temp2) do
		deqeueue(temp2,val)
		if Qth=0 and cnt1<Q1.length then
			enqueue(Q1,val)
			cnt1<-cnt1+1
		else if Qth=1 and cnt2<Q2.length then
			enqueue(Q2,val)
			cnt2<-cnt2+1
		else if (Qth=2 and cnt3<Q3.length) then
			enqueue(Q3,val)
			cnt3<-cnt3+1
		Qth<-(Qth+1)%3


procedure roundRobin (input/output q: queue, input t: integer)
{Proses	: memproses elemen antrian q secara round robin}
{IS	: q tidak kosong, t adalah waktu yang tersedia untuk memproses setiap elemen}
{FS	: elemen e pada posisi HEAD dihapus dari q.
	  Jika cost e ≤ t maka ditampilkan “<id> telah selesai diproses”.
	  Jika cost e > t maka e disisipkan kembali sebagai tail q
	  dengan cost berkurang sebesar t }
KAMUS LOKAL
i : integer
head_val : ElType

ALGORITMA
i ← q.idxHead
head_val.id ← 0
head_val.cost ← 0

repeat
	dequeue(q, head_val)
	if (head_val.cost ≤ t) then
		output(head_val.id + " telah selesai diproses")
	else 
		head_val.cost ← head_val.cost - t
		enqueue(q, head_val)
	i ← i + 1
until (i = q.idxTail-1)

 
MESIN KATA

Program CekOpensesame

KAMUS
	USE MesinKata1

ALGORITMA
startKata
if endKata do
	output("Pita karakter kosong")
else
	{inisialisasi kataOpensesame}
	kataOpensesame.buffer[0] <- 'O'
	kataOpensesame.buffer[1] <- 'p'
	kataOpensesame.buffer[2] <- 'e'
	kataOpensesame.buffer[3] <- 'n'
	kataOpensesame.buffer[4] <- 's'
	kataOpensesame.buffer[5] <- 'e'
	kataOpensesame.buffer[6] <- 's'
	kataOpensesame.buffer[7] <- 'a'
	kataOpensesame.buffer[8] <- 'm'
	kataOpensesame.buffer[9] <- 'e'
	kataOpensesame.length <- 10

	i<-0
	diff <- false
	while not endKata and i<10 and not diff do 
		if currentKata.buffer[0]=kataOpensesame[i]
			i<-i+1
		else
			diff<-true
		advKata
	if not diff then
		output("Open sesame!")
	else
		output("Bukan pita yang tepat")










Program FK1
{ Program untuk menghitung frekuensi kemunculan kata pertama dalam pita }

KAMUS
USE MesinKata1
constant N_MAX: integer = 50
Kata1: Kata
i, nbK1, totalK: integer

ALGORITMA
startKata
if ( not endKata ) then
i traversal [0..currentKata.length-1]
Kata1.buffer[i] ← currentKata.buffer[i]
Kata1.length ← currentKata.length
nbK1 ← 1
totalK ← 1
advKata
while not endKata do
if (isKataEqual(currentKata, Kata1)) then
nbK1 ← nbK1 + 1
totalK ← totalK + 1
output(“Frekuensi kata pertama adalah “+nbK1+”/”+totalK)

else { endKata }
output(“Pita kosong”)




Program Anagram
{ Program yang membaca sebuah pita karakter, dan menuliskan ke layar
ada berapa banyak kata yang ANAGRAM dengan kata pertama pada pita karakter
tersebut (tidak termasuk kata pertama). }

KAMUS
USE MesinKata1
function isAnagram(k1, k2: Kata) → boolean
kata1: Kata
totalK: integer

ALGORITMA
startKata
kata1 ← currentKata
advKata
totalK ← 0
while (not endKata) do
if (isAnagram(kata1, currentKata) then
total ← total + 1
advKata
else
advKata
output(total)


function isAnagram(k1,k2: Kata) → Boolean

KAMUS LOKAL
i,j : integer
frekuensi: array [0..N_MAX -1] of integer

ALGORITMA
If (k1.length != k2.length) then
→ False
else
i traversal [0..N_MAX-1]
frekuensi[i] ← 0
i traversal [0..k1.length-1]
kondisi ← False
j traversal [0..x.length-1]
if (x.buffer[i] = y.buffer[j] and frekuensi[j] == 0) then
kondisi ← True
frekuensi[j] ← frekuensi[j] +1
if not kondisi then
→ False
→ True

	









Program Mesin Token
{ menuliskan ekspresi matematika dalam pita ke layar }

KAMUS
	USE MesinKata1
	i, j : integer
	newArr : array[0..N_MAX-1] of Kata
	needBrackets : boolean
ALGORITMA
	i ← 0
	startKata
	while (not endKata) do
		if (not isOperator(currentKata)) then
			newArr[i].length ← currentKata.length
			j traversal [0..(currentKata.length-1)]
				newArr[i].buffer[j] ← currentKata.buffer[j]
		else
			newArr[i-2] ← PostfixToInfix(newArr[i-2], newArr[i-1], currentKata, needBrackets)
		
		i ← i -1
		needBrackets ← false
	output(newArr[0])

function PostfixToInfix (o1, o2, op: Kata, brackets: boolean) → Kata

KAMUS LOKAL
	i, j : integer
	out : Kata
ALGORITMA
	i ←0
	if (brackets) then
		out.buffer[i] ← “(“
		i ← i + 1
	j traversal [0..(o1.length-1)]
		out.buffer[i] ← o1.buffer[j]
		i ← i + 1
	out.buffer[i] ← BLANK 
	i ← i + 1
	out.buffer[i] ← op.buffer[0]
	i ← i + 1
	out.buffer[i] ← BLANK

	j traversal [0..(o2.length-1)]
		out.buffer[i] ← o2.buffer[j]
		i ← i + 1
	if (brackets) then
		out.buffer[i] ← “)”
		i ← i + 1
	out.length ← i
	→ out

function isOp (token: Kata) → boolean
KAMUS LOKAL
ALGORITMA
	→ (token.buffer[0] = “*”) or (token.buffer[0] = “/”) or (token.buffer[0]=”+”) or (token.buffer[0] = “-“) or (token.buffer[0] = “^”)

 
MATRIX
#include <stdio.h>
#include <stdbool.h>

#define UNDEF -9999
#define ROW_CAP 100
#define COL_CAP 100

typedef int ElType;

typedef struct {
    ElType mem[COL_CAP][ROW_CAP];
    int rowEff;
    int colEff;
} Matrix;

void CreateMatrix(Matrix *m, int nRows, int nCols) {
    m->rowEff = nRows;
    m->colEff = nCols;
    int i, j;
    for (i = 0; i < nCols; ++i) {
        for (j = 0; j < nRows; ++j) {
            m->mem[i][j] = UNDEF;
        }
    }
}

int getRowEff(Matrix m) {
    return m.rowEff;
}

int getCollEff(Matrix m) {
    return m.colEff;
}

bool isMatrixIdxValid(int i, int j) {
    return i >= 0 && i < COL_CAP && j >= 0 && j < ROW_CAP;
}

bool isIdxEff(Matrix m, int i, int j) {
    return i >= 0 && i < m.colEff && j >= 0 && j < m.rowEff;
}

ElType getElmt(Matrix m, int i, int j) {
    if (isIdxEff(m, i, j)) {
        return m.mem[i][j];
    } else {
        return UNDEF;
    }
}

ElType vlookup(ElType val, Matrix m, int col) {
    int i, rowIdx = -1;

    // Mencari baris dengan nilai val di kolom pertama
    for (i = 0; i < m.rowEff; ++i) {
        if (m.mem[0][i] == val) {
            rowIdx = i;
            break;
        }
    }

    // Jika val tidak ada di kolom pertama atau col di luar indeks yang valid, kembalikan UNDEF
    if (rowIdx == -1 || col < 0 || col >= m.colEff) {
        return UNDEF;
    }
    // Mengambil nilai di kolom ke-col pada baris yang ditemukan tadi
    return m.mem[col][rowIdx];
}








STACK
procedure copyStack(input sIn: Stack, output sOut: Stack)
{ Membuat salinan sOut }
{ I.S. sIn terdefinisi, sOut sembarang }
{ F.S. sOut berisi salinan sIn yang identik }
KAMUS
  val : ElType
  temp : Stack
ALGORITMA
  createStack(sOut)
  createStack(temp)
  val ← 0
i traversal [sIn.idxTop .. 0]
  pop(sIn, val)
  push(Temp, val)
i traversal [sIn.idxTop .. 0]
  pop(temp, val)	
  push(sIn, val)
  push(sOut, val)
 
procedure inverseStack(input/output s: Stack)
{ Membalik isi suatu stack }
{ I.S. s terdefinisi }
{ F.S. Isi s terbalik dari posisi semula }
KAMUS
  temp : Stack
  val, buang : ElType
  i : integer
ALGORITMA
  createStack(temp)
  val ← 0
  buang ← 0
  copyStack(s, temp)
  i traversal [s.idxTop .. 0]
    pop(s, buang)
    i traversal [s.idxTop .. 0]
      pop(temp, val)
      push(s, val)

function mergeStack(s1,s2: Stack) → Stack
{ Menghasilkan sebuah stack yang merupakan hasil penggabungan s1
dengan s2 dengan s1 berada di posisi lebih “bawah”. Urutan kedua
stack harus sama seperti aslinya. }
{ Stack baru diisi sampai seluruh elemen s1 dan s2 masuk ke dalam
stack, atau jika stack baru sudah penuh, maka elemen yang
dimasukkan adalah secukupnya yang dapat ditampung. }
KAMUS
  S, s1c, s2c : stack
ALGORITMA
  createStack(s1c)
  copyStack(inverseStack(s1), s1c)
  while ( not (isFull(S)) )
    pop (s1c, val)
    push(S, val)

  createStack(s2c)
  copyStack(inverseStack(s2), s2c)
  while ( not (isFull(S)) )
    pop (s2c, val)
    push(S, val)
  → S

function charToInt (operan: Token) → integer
{ Fungsi mengubah operan dari karakter ke integer }
KAMUS LOKAL
  newInt, i : integer;
ALGORITMA FUNGSI
  i traversal [0..operan.length-1]
    if (operan.buffer[i] = '1') then
      newInt ← newInt + 1
    else if (operan.buffer[i] = '2') then
      newInt ← newInt + 2
    else if (operan.buffer[i] = '3') then
      newInt ← newInt + 3
    else if (operan.buffer[i] = '4') then
      newInt ← newInt + 4
    else if (operan.buffer[i] = '5') then
      newInt ← newInt + 5
    else if (operan.buffer[i] = '6') then
      newInt ← newInt + 6
    else if (operan.buffer[i] = '7') then
      newInt ← newInt + 7
    else if (operan.buffer[i] = '8') then
      newInt ← newInt + 8
    else if (operan.buffer[i] = '9') then
      newInt ← newInt + 9
    else { operan.buffer[i] = 0 }
      newInt ← newInt
    newInt ← newInt * 10

  → newInt

function intToChar (angka: integer) → Token
{ Fungsi mengubah angka menjadi token }
KAMUS LOKAL
  i, dig, sisa, temp: integer;
  newTok : Token;
ALGORITMA FUNGSI
  dig ← 1
  temp ← angka
  while ( temp > 9 ) do
    temp ← temp // 10
    dig ← dig+1

  temp ← angka
  sisa ← 0
  i ← dig
  while ( temp > 9 ) do
    sisa ← temp mod 10
    if (sisa == 1) then
      newTok.buffer[i] ← '1'
    else if (sisa == 2) then
      newTok.buffer[i] ← '2'
    else if (sisa == 3) then
      newTok.buffer[i] ← '3'
    else if (sisa == 4) then
      newTok.buffer[i] ← '4'
    else if (sisa == 5) then
      newTok.buffer[i] ← '5'
    else if (sisa == 6) then
      newTok.buffer[i] ← '6'
    else if (sisa == 7) then
      newTok.buffer[i] ← '7'
    else if (sisa == 8) then
      newTok.buffer[i] ← '8'
    else if (sisa == 9) then
      newTok.buffer[i] ← '9'
    else { sisa == 0 }
      newTok.buffer[i] ← '0'
    temp ← temp // 10
    i ← i - 1
        
    newTok.buffer[i] ← temp
    newTok.length ← dig

function isOperator(token: Token) → boolean
{ memeriksa apakah suatu token merupakan operator }
KAMUS LOKAL

ALGORITMA FUNGSI
  → (token.buffer[0] = '+' or token.buffer[0] = '*' or token.buffer[0] = '-' or token.buffer[0] = '/')

function evaluate(op1, op2, operator: Token) → Token
{ mengevaluasi ekspresi matematika berdasarkan op1, op2, dan operator }
KAMUS LOKAL
  hasil, operand1, operand2 : integer
ALGORITMA
  hasil ← 0
  operand1 ← charToInt(op1)
  operand2 ← charToInt(op2)
    
  if (operator = '+') then
    hasil ← operand1 + operand2
  else if (operator = '*') then
    hasil ← operand1 + operand2 
  else if (operator = '-') then
    hasil ← operand1 + operand2 
  else { operator = '/' }
    hasil ← operand1 / operand2
    
  → intToChar(hasil)
