#include <stdio.h>
#include "boolean.h"
#include "stack.h"

/* ************ Prototype ************ */
/* *** Konstruktor/Kreator *** */
void CreateEmpty(Stack* S){
    Top(*S) = Nil;
}
/* I.S. sembarang; */
/* F.S. Membuat sebuah stack S yang kosong berkapasitas MaxEl */
/* jadi indeksnya antara 0..MaxEl-1 (inklusif) */
/* Ciri stack kosong : TOP bernilai Nil */

/* ************ Predikat Untuk test keadaan KOLEKSI ************ */
boolean IsEmpty(Stack S){
    return Top(S) == Nil;
}
/* Mengirim true jika Stack kosong: lihat definisi di atas */

boolean IsFull(Stack S){
    return Top(S) == MaxEl-1;
}
/* Mengirim true jika tabel penampung nilai elemen stack penuh */

/* ************ Menambahkan sebuah elemen ke Stack ************ */
void Push(Stack * S, infotype X){
    Top(*S)++;
    InfoTop(*S) = X;
}
/* Menambahkan X sebagai elemen Stack S. */
/* I.S. S mungkin kosong, tabel penampung elemen stack TIDAK penuh */
/* F.S. TOP bertambah 1, X menjadi TOP yang baru, */

/* ************ Menghapus sebuah elemen Stack ************ */
void Pop(Stack * S, infotype* X){
    *X = InfoTop(*S);
    Top(*S)--;
}
/* Menghapus X dari Stack S. */
/* I.S. S  tidak mungkin kosong */
/* F.S. X adalah nilai elemen TOP yang lama, TOP berkurang 1 */



///////////////////////////////////////////divide//////////////////////////////////////////////////////////////

#include "stack.h"

void divideStack(Stack *s, Stack *oddS, Stack *evenS){
    Stack tempS;
    infotype to_temp, to_real;

    CreateEmpty(&tempS);

    while (!IsEmpty(*s)){
        Pop(s, &to_temp);
        Push(&tempS, to_temp);
    }
    while(!IsEmpty(tempS)){
        Pop(&tempS, &to_real);
        if (to_real%2 == 0){
            Push(evenS, to_real);
        } else {
            Push(oddS, to_real);
        }
    }
}
/*
Memisahkan nilai genap dan nilai ganjil dari Stack s.

Awal:
s: 1,2,3,4
evenS:
oddS:

Akhir:
s: 
evenS 2,4
oddS: 1,3

Perhatikan order di dalam stacknya

*/







//////////////////////////////////////aritmatika///////////////////////////////////////////////////////





#include "stack.h"
#include "boolean.h"
#include "string.h"
#include "stdlib.h"

boolean isOperator(char input){
    return (input == '+' || input == '-' || input == '*' || input == '/');
}
/* Proses: Mengecek apakah input merupakan operator */
/*         input adalah operator jika input merupakan salah
           satu dari berikut:
                - +
                - -
                - *
                - /
*/

int hitung(int angka1, int angka2, char op){
    if (op == '+') {
        return (angka1 + angka2);
    } else if (op == '-') {
        return (angka1 - angka2);
    } else if (op=='*') {
        return (angka1 * angka2);
    } else {
        return (int) (angka1 / angka2);
    }
}
/* Proses: Menghitung ekspresi */
/*
    Contoh input / output:
    angka1 : 2
    angka2 : 10
    op     : -

    return : -8 (penjelasan: 2 - 10 = 8)
*/

int eval(char *input, int length){
    Stack operations;
    int i;
    infotype operand1, operand2, result;

    CreateEmpty(&operations);
    for (i = 0; i < length; i++) {
        // printf("%c", input[i]);
        if (isOperator(input[i])){
            Pop(&operations, &operand2);
            Pop(&operations, &operand1);
            Push(&operations, (hitung(operand1, operand2, input[i])));
        } else {
            Push(&operations, input[i]-'0');
        }
    }
    Pop(&operations, &result);
    return result;
}
/* Proses: Menghitung keseluruhan ekspresi */
/* I.S. input adalah string. setiap operand dipastikan < 10 */
/*
    Contoh input / output:
    input   : 23+
    output  : 5 (penjelasan: ekspresi ekuivalen dengan 2 + 3)

    input   : 9423+*5/-
    output  : 5 (penjelasan: ekspresi ekuivalen dengan 9-(4*(2+3))/5)

*/









////////////////////////////////////browserhistory//////////////////////////////////////////////







// NIM             : 18221048
// Nama            : Syafiq Ziyadul Arifin
// Tanggal         : 21 Oktober 2022
// Topik praktikum : Praktikum 7
// Deskripsi       : Implementasi dari browserhistory.h

#include <stdio.h>
#include "browserhistory.h"

void browserHistoryVisit(Stack *openedTab, Stack *history, char *url)
{
    Push(openedTab, url);
    Push(history, url);
}

char *currentUrl(Stack *openedTab)
{
    return InfoTop(*openedTab);
}

char *browserHistoryBack(Stack *openedTab, Stack *history, int steps)
{
    int i;
    infotype url;
    for (i = 0; i < steps; i++)
    {
        Pop(openedTab, &url);
        Push(history, url);
    }
    return currentUrl(openedTab);
}

char *browserHistoryForward(Stack *openedTab, Stack *history, int steps)
{
    int i;
    infotype url;
    for (i = 0; i < steps; i++)
    {
        Pop(history, &url);
        Push(openedTab, url);
    }
    return currentUrl(openedTab);
}

void browserHistoryFree(Stack *history)
{
    CreateEmpty(history);
}





/////////////////////////////////palindrom//////////////////////////////////////////






// NIM             : 18221048
// Nama            : Syafiq Ziyadul Arifin
// Tanggal         : 21 Oktober 2022
// Topik praktikum : Pra-praktikum 7
// Deskripsi       : Menerima masukan sampai mendapat masukan 0,
//                   cek apakah bilangan palindrom

#include "stack.h"

Stack ReverseStack(Stack s)
{
    int temp;
    Stack S;
    CreateEmpty(&S);
    while (!IsEmpty(s))
    {
        Pop(&s, &temp);
        Push(&S, temp);
    }
    return S;
}

int main()
{
    int inp;
    Stack s1;
    CreateEmpty(&s1);
    scanf("%d", &inp);
    while (inp != 0)
    {
        Push(&s1, inp);
        scanf("%d", &inp);
    }
    if (!IsEmpty(s1))
    {
        int temp1, temp2;
        boolean isPalindrom = true;
        Stack s2 = ReverseStack(s1);
        while (!IsEmpty(s1) && isPalindrom)
        {
            Pop(&s1, &temp1);
            Pop(&s2, &temp2);
            if (temp1 != temp2)
                isPalindrom = false;
        }
        if (isPalindrom)
            printf("Palindrom\n");
        else
            printf("Bukan Palindrom\n");
    }
    else
        printf("Stack kosong\n");
}









////////////////////////////////pengurangan////////////////////////////////////////////////////







// NIM             : 18221048
// Nama            : Syafiq Ziyadul Arifin
// Tanggal         : 24 Oktober 2022
// Topik praktikum : Praktikum 7
// Deskripsi       : Pengurangan integer yang direpresentasikan
//                   dengan string (implementasi stack)

#include <stdio.h>
#include "stack.h"

int main()
{
	char str1[100], str2[100];
	Stack s1, s2, s;
	int i = 0, j = 0, k = 0;
	int temp = 0, temp1, temp2, res;
	boolean isNeg = false, startNull = true;
	CreateEmpty(&s1), CreateEmpty(&s2), CreateEmpty(&s);
	scanf("%s\n%s", str1, str2);
	while (str1[i] != '\0')
	{
		Push(&s1, (int)str1[i] - '0');
		i++;
	}
	while (str2[j] != '\0')
	{
		Push(&s2, (int)str2[j] - '0');
		j++;
	}
	if (j > i) isNeg = true;
	else if (j == i)
	{
		while (k <= i && !isNeg)
		{
			if (str2[k] > str1[k]) isNeg = true;
			k++;
		}
	}
	while (!IsEmpty(s1) || !IsEmpty(s2))
	{
		if (!IsEmpty(s1)) Pop(&s1, &temp1);
		else temp1 = 0;
		if (!IsEmpty(s2)) Pop(&s2, &temp2);
		else temp2 = 0;
		
		if (!isNeg) res = temp1 - temp2 - temp;
		else res = temp2 - temp1 - temp;
		if (res < 0) res += 10;
		Push(&s, res);
		if ((temp1 < temp2 && !isNeg) || (temp2 < temp1 && isNeg))
			temp = 1;
		else if ((temp1 > temp2 && !isNeg) || (temp2 > temp1 && isNeg))
			temp = 0;
	}
	if (isNeg) printf("-");
	while (!IsEmpty(s))
	{
		Pop(&s, &temp);
		if (startNull && temp != 0) startNull = false;
		if (!startNull) printf("%d", temp);
	}
	if (IsEmpty(s) && startNull) printf("0");
	printf("\n");
}







////////////////////////////////////////valid/////////////////////////////////////////////////////////









// NIM             : 18221048
// Nama            : Syafiq Ziyadul Arifin
// Tanggal         : 24 Oktober 2022
// Topik praktikum : Praktikum 7
// Deskripsi       : Implementasi dari valid.h

#include <stdio.h>
#include "valid.h"

Stack validParantheses(char* input, int length)
{
	int i;
	Stack s;
	CreateEmpty(&s);
	for (i = 0; i < length - 1; i++)
	{
		if (input[i] == '(' && input[i+1] == ')')
		{
			Push(&s, '(');
			Push(&s, ')');
		}
		else if (input[i] == '{' && input[i+1] == '}')
		{
			Push(&s, '{');
			Push(&s, '}');
		}
		else if (input[i] == '[' && input[i+1] == ']')
		{
			Push(&s, '[');
			Push(&s, ']');
		}
	}
	return s;
}






////////////////////////ekspresi////////////////////////////////////////////////////





#include "mesintoken.h"
#include "mesinkar.h"
#include "stackt.h"
#include <stdio.h>

int main(){
    STARTTOKEN();
    IgnoreBlank();

    Stack setek, setek2;
    CreateEmpty(&setek);
    CreateEmpty(&setek2);

    int result = 0, finalresult = 0;
    boolean empty = true;

    while (!EndToken){
        result = 0;
        if (empty){
            empty = false;
        }
        if (CToken.tkn == 'b'){
            Push(&setek, CToken.val);
            printf("%d\n", CToken.val);
        } else {
            int A, B;
            if (Top(setek) >= 1){
                Pop(&setek, &B);
                Pop(&setek, &A);
            }
            if (CToken.tkn == '+'){
                result = A+B;
                printf("%d + %d\n%d\n", A, B, result);
            } else if (CToken.tkn == '-'){
                result = A-B;
                printf("%d - %d\n%d\n", A, B, result);
            } else if (CToken.tkn == '*'){
                result = A*B;
                printf("%d * %d\n%d\n", A, B, result);
            } else if (CToken.tkn == '/'){
                result = A/B;
                printf("%d / %d\n%d\n", A, B, result);
            } else if (CToken.tkn == '^'){
                int i;
                int base = 1;
                for (i=0;i<B;i++){
                    base *= A;
                }
                result = base;
                printf("%d ^ %d\n%d\n", A, B, result);
            }
            Push(&setek, result);
            finalresult = result;
        }

        IgnoreBlank();
        ADVTOKEN();
    }

    if (!IsEmpty(setek)){
        Pop(&setek, &result);
    }

    if (empty){
        printf("Ekspresi kosong\n");
    } else {
        printf("Hasil=%d\n", result);
    }
}









/////////////////////////////////////backspace//////////////////////////////////////////////////










#include <stdio.h>
#include "stackt.h"
#include "boolean.h"

int main(){
    int N,M,i;
    scanf("%d %d", &N, &M);
    Stack SN, SM;

    CreateEmpty(&SN);
    CreateEmpty(&SM);
    for (i=0;i<(N+M);i++){
        int X;
        scanf("%d", &X);
        if (i < N){
            if (X == 0){
                if (Top(SN) != Nil){
                    Pop(&SN, &X);
                    continue;
                }
            } else {
                Push(&SN, X);
            }
        } else {
            if (X == 0){
                if (Top(SM) != Nil){
                    Pop(&SM, &X);
                    continue;
                }
            } else {
                Push(&SM, X);
            }
        }
    }
    int min = (Top(SN) <= Top(SM) ? Top(SN) : Top(SM));
    if (min != -1){
        for (i=0;i<=min;i++){
            int X;
            if (IsEmpty(SN) || IsEmpty(SM)) break;

            if (InfoTop(SN) == InfoTop(SM)){
                Pop(&SN, &X);
                Pop(&SM, &X);
            }
        }
    }
    printf((IsEmpty(SN) && IsEmpty(SM)) ? ("Sama\n") : ("Tidak sama\n"));
    return 0;
}








////////////////////////////////////rekursiv/////////////////////////////////////////////////







#include <stdio.h>
#include "boolean.h"
#include "stack.h"

/* *** Implementasi dengan menggunakan rekursi *** */

/* Fungsi rekursif untuk menambahkan elemen ke Stack */
void PushRecursive(Stack *S, infotype X) {
    if (IsEmpty(*S)) {
        CreateEmpty(S);
    }
    if (IsFull(*S)) {
        printf("Stack is full, cannot push %d\n", X);
        return;
    } else {
        Stack TempStack;
        CreateEmpty(&TempStack);
        infotype Temp;
        Pop(S, &Temp);
        PushRecursive(&TempStack, X);
        Push(&TempStack, Temp);
        *S = TempStack;
    }
}

/* Fungsi rekursif untuk menghapus elemen dari Stack */
void PopRecursive(Stack *S, infotype *X) {
    if (IsEmpty(*S)) {
        printf("Stack is empty\n");
        return;
    }
    if (Top(*S) == 0) {
        *X = InfoTop(*S);
        Top(*S) = Nil;
    } else {
        infotype Temp;
        Stack TempStack;
        CreateEmpty(&TempStack);
        Pop(S, &Temp);
        PopRecursive(S, X);
        Push(&TempStack, Temp);
        *S = TempStack;
    }
}

/* Fungsi rekursif untuk menampilkan elemen Stack */
void DisplayRecursive(Stack S) {
    if (IsEmpty(S)) {
        return;
    }
    infotype Temp;
    Pop(&S, &Temp);
    DisplayRecursive(S);
    printf("%d ", Temp);
    Push(&S, Temp);
}

int main() {
    Stack S;
    CreateEmpty(&S);

    PushRecursive(&S, 1);
    PushRecursive(&S, 2);
    PushRecursive(&S, 3);

    printf("Stack elements: ");
    DisplayRecursive(S);
    printf("\n");

    infotype X;
    PopRecursive(&S, &X);
    printf("Popped element: %d\n", X);

    printf("Stack elements after pop operation: ");
    DisplayRecursive(S);
    printf("\n");

    return 0;
}







///////////////////////ekspresi token////////////////////////////////////






/*
NIM                 : 13520065
Nama                : Rayhan Kinan Muhannad
Tanggal             : 21 Oktober 2021
Topik Praktikum     : ADT Stack
Deskripsi           : Driver ADT Stack dan ADT Mesin Kata untuk mengevaluasi ekspresi matematika postfix
*/

#include "stack.h"
#include "tokenmachine.h"
#include <stdio.h>
#include <math.h>

boolean isOperator() {
    /* KAMUS */

    /* ALGORITMA */
    return (currentToken.tkn != 'b');
}

int evaluate(int N1, int N2, char CC) {
    /* KAMUS */
    int hasil;

    /* ALGORITMA */
    switch (CC) {
        case '+':
            hasil = N1 + N2;
            break;
        case '-':
            hasil = N1 - N2;
            break;
        case '*':
            hasil = N1 * N2;
            break;
        case '/':
            hasil = N1 / N2;
            break;
        case '^':
            hasil = pow(N1, N2);
            break;
    }

    return hasil;
}

int main() {
    /* KAMUS */
    Stack S;
    ElType N1, N2;

    /* ALGORITMA */
    CreateStack(&S);

    startToken();

    if (endToken) {
        printf("Ekspresi kosong\n");
    } else {
        do {
            if (!isOperator()) {
                push(&S, currentToken.val);

                printf("%d\n", currentToken.val);
            } else {
                pop(&S, &N2);
                pop(&S, &N1);
                push(&S, evaluate(N1, N2, currentToken.tkn));

                printf("%d %c %d\n", N1, currentToken.tkn, N2);
                printf("%d\n", evaluate(N1, N2, currentToken.tkn));
            }
            advToken();
        } while (!endToken);
        printf("Hasil=%d\n", TOP(S));
    }
}

